<!doctype html>
<html>
  <body>
    <button id="btnConnect">Connect</button>
    <button id="btnOpenMM" disabled>Open MetaMask</button>
    <button id="btnDisconnect" disabled>Disconnect</button>

    <pre id="log"></pre>
    <div id="loadingMessage" style="display:none;">Please wait, connecting and switching to Sepolia...</div>
    <div id="errorMessage" style="display:none; color: red;"></div>
    <div id="retryMessage" style="display:none; color: orange;">Retrying to switch networks...</div>

    <!-- WalletConnect v2 EthereumProvider (UMD build, no bundler) -->
    <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.23.3/dist/index.umd.js"></script>

    <script>
      const logEl = document.getElementById("log");
      const btnConnect = document.getElementById("btnConnect");
      const btnOpenMM = document.getElementById("btnOpenMM");
      const btnDisconnect = document.getElementById("btnDisconnect");
      const loadingMessage = document.getElementById("loadingMessage");
      const errorMessage = document.getElementById("errorMessage");
      const retryMessage = document.getElementById("retryMessage");

      function log(...args) {
        logEl.textContent += args.map(String).join(" ") + "\n";
      }

      function showLoading(message) {
        loadingMessage.style.display = "block";
        loadingMessage.textContent = message;
      }

      function hideLoading() {
        loadingMessage.style.display = "none";
      }

      function showError(message) {
        errorMessage.style.display = "block";
        errorMessage.textContent = message;
      }

      function hideError() {
        errorMessage.style.display = "none";
      }

      function showRetryMessage(message) {
        retryMessage.style.display = "block";
        retryMessage.textContent = message || "Retrying to switch networks...";
      }

      function hideRetryMessage() {
        retryMessage.style.display = "none";
      }

      // ---- CONFIG ----
      const projectId = "19acc37cc9d91b4b39b0cca952297654"; // Replace with your WalletConnect project ID

      // Sepolia
      const SEPOLIA = 11155111;
      const SEPOLIA_HEX = "0xaa36a7"; // 11155111
      const SEPOLIA_RPC_PRIMARY = "https://rpc.sepolia.org";
      const SEPOLIA_RPC_SECONDARY = "https://rpc2.sepolia.org";
      const SEPOLIA_EXPLORER = "https://sepolia.etherscan.io";

      // ---- STATE ----
      let provider = null;
      let wcUri = null;

      // For "switch on resume" behavior
      let pendingSwitch = false;
      let switchingInProgress = false;
      let switchAttempts = 0;

      async function ensureProvider() {
        if (provider) return provider;

        const WC = window["@walletconnect/ethereum-provider"];
        if (!WC?.EthereumProvider) throw new Error("WalletConnect EthereumProvider not loaded");

        provider = await WC.EthereumProvider.init({
          projectId,
          showQrModal: false,
          metadata: {
            name: "Bare WC Demo",
            description: "WalletConnect v2 bare HTML (Chrome + MetaMask Mobile)",
            url: location.origin,
            icons: ["https://metamask.io/images/favicon-32.png"]
          },
          optionalChains: [SEPOLIA],
          rpcMap: { [SEPOLIA]: SEPOLIA_RPC_PRIMARY }
        });

        provider.on("display_uri", (uri) => {
          wcUri = uri;
          log("display_uri ready");
          btnOpenMM.disabled = false;
        });

        provider.on("connect", (info) => {
          log("connected:", JSON.stringify(info));
          btnDisconnect.disabled = false;
        });

        provider.on("disconnect", () => {
          log("disconnected");
          btnOpenMM.disabled = true;
          btnDisconnect.disabled = true;
          wcUri = null;

          pendingSwitch = false;
          switchingInProgress = false;
          switchAttempts = 0;

          hideLoading();
          hideRetryMessage();
        });

        provider.on("accountsChanged", (accounts) => {
          log("accountsChanged:", JSON.stringify(accounts));
          if (accounts && accounts[0]) log("account:", accounts[0]);
        });

        provider.on("chainChanged", (chainId) => {
          log("chainChanged:", String(chainId));
        });

        return provider;
      }

      async function ensureSepoliaNetwork() {
        // Check current chain
        const currentHex = await provider.request({ method: "eth_chainId" });
        log("current chainId:", currentHex);

        if (String(currentHex).toLowerCase() === SEPOLIA_HEX) {
          log("Already on Sepolia.");
          return;
        }

        // Try switch first
        try {
          showLoading("Requesting switch to Sepolia...");

          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: SEPOLIA_HEX }]
          });

          log("Switched to Sepolia.");
          hideLoading();
          return;
        } catch (e) {
          const code = e && (e.code ?? e?.data?.originalError?.code);
          const msg = e && (e.message || String(e));

          log("switch error:", msg);

          // 4902 = chain not added (common MetaMask behavior)
          if (code === 4902) {
            showLoading("Sepolia not added. Requesting add network...");

            await provider.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: SEPOLIA_HEX,
                chainName: "Sepolia",
                nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
                rpcUrls: [SEPOLIA_RPC_PRIMARY, SEPOLIA_RPC_SECONDARY],
                blockExplorerUrls: [SEPOLIA_EXPLORER]
              }]
            });

            showLoading("Network add requested. Now switching to Sepolia...");

            await provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: SEPOLIA_HEX }]
            });

            log("Switched to Sepolia after adding.");
            hideLoading();
            return;
          }

          // 4001 = user rejected in MetaMask (common)
          if (code === 4001) {
            showError("You rejected the Sepolia switch/add request in MetaMask.");
            hideLoading();
            throw e;
          }

          // Other errors
          showError("Unable to switch to Sepolia. Please open MetaMask and approve any pending prompts.");
          hideLoading();
          throw e;
        }
      }

      function isSessionLikelyReadyError(e) {
        const msg = (e && (e.message || String(e))) || "";
        // Heuristic: different wallets throw slightly different texts when WC session isn't fully ready.
        return /not (initialized|connected)|disconnected|session|provider|not ready|transport/i.test(msg);
      }

      async function tryAutoSwitch(origin) {
        // Only run if we said we intend to switch
        if (!pendingSwitch || !provider) return;

        // Avoid overlapping attempts
        if (switchingInProgress) return;

        switchingInProgress = true;

        try {
          hideError();
          hideRetryMessage();

          log(`[auto] triggered by: ${origin}`);

          // Backoff schedule: fast but not spammy
          const delays = [0, 350, 900, 1800];

          for (let i = 0; i < delays.length; i++) {
            switchAttempts = i + 1;

            if (delays[i] > 0) {
              showRetryMessage(`Preparing Sepolia switch (attempt ${switchAttempts}/${delays.length})...`);
              await new Promise((r) => setTimeout(r, delays[i]));
            } else {
              showRetryMessage(`Preparing Sepolia switch (attempt ${switchAttempts}/${delays.length})...`);
            }

            try {
              await ensureSepoliaNetwork();
              // Success
              pendingSwitch = false;
              hideRetryMessage();
              hideLoading();
              log("[auto] Sepolia switch complete.");
              return;
            } catch (e) {
              // If the user rejected, stop retrying (no point nagging)
              const code = e && (e.code ?? e?.data?.originalError?.code);
              if (code === 4001) {
                log("[auto] user rejected request, stopping auto switch.");
                pendingSwitch = false;
                hideRetryMessage();
                return;
              }

              // If it's likely a "session not ready" style error, keep looping.
              // Otherwise, also keep looping a bit, but we'll show a clearer message at the end.
              log(`[auto] attempt ${switchAttempts} failed:`, e?.message || e);
              if (i === delays.length - 1) {
                showError("Still waiting for MetaMask/WalletConnect to be ready. Tap 'Open MetaMask' and check for a pending prompt.");
                hideRetryMessage();
              }
            }
          }
        } finally {
          switchingInProgress = false;
        }
      }

      // Auto-trigger switching when the page becomes active again
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) tryAutoSwitch("visibilitychange");
      });

      window.addEventListener("focus", () => tryAutoSwitch("focus"));
      window.addEventListener("pageshow", () => tryAutoSwitch("pageshow"));

      btnConnect.onclick = async () => {
        try {
          hideError();
          hideRetryMessage();
          showLoading("Please wait, connecting (MetaMask approval needed)...");

          await ensureProvider();

          log("Starting connection. Tap 'Open MetaMask' -> approve -> return here.");

          // Triggers display_uri; resolves after wallet approval (when user returns to dapp)
          await provider.connect();

          // Mark that we want to switch, and let resume hooks handle it immediately on return.
          pendingSwitch = true;

          // Try immediately too (in case the runtime is still active and ready)
          await tryAutoSwitch("post-connect");

          btnDisconnect.disabled = false;
        } catch (e) {
          log("connect error:", e?.message || e);
          showError("Connection failed. Try again, then tap 'Open MetaMask' if needed.");
          hideLoading();
        }
      };

      btnOpenMM.onclick = () => {
        if (!wcUri) return;

        const uri = encodeURIComponent(wcUri);
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Android: scheme often preserves wc params better.
        const schemeLink = `metamask://wc?uri=${uri}`;
        // Fallback
        const universalLink = `https://metamask.app.link/wc?uri=${uri}`;

        const target = isAndroid ? schemeLink : universalLink;
        log("Opening MetaMask via:", target);
        location.href = target; // user-gesture navigation
      };

      btnDisconnect.onclick = async () => {
        try {
          if (!provider) return;
          await provider.disconnect();
        } catch (e) {
          log("disconnect error:", e?.message || e);
        }
      };
    </script>
  </body>
</html>
















