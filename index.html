<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WC + ethers (One Button)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    button { font-size: 18px; padding: 14px 18px; border-radius: 10px; border: 1px solid #bbb; background: #f7f7f7; }
    button:disabled { opacity: 0.5; }
    #log { margin-top: 14px; white-space: pre-wrap; }
    #loadingMessage, #errorMessage { margin-top: 10px; }
  </style>
</head>

<body>
  <button id="btnDoIt">Send Test Tx (from JS)</button>
  <div id="loadingMessage" style="display:none;">Working…</div>
  <div id="errorMessage" style="display:none; color: red;"></div>
  <pre id="log"></pre>

  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.23.3/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

  <script>
    // ---------------- UI ----------------
    const logEl = document.getElementById("log");
    const btnDoIt = document.getElementById("btnDoIt");
    const loadingMessage = document.getElementById("loadingMessage");
    const errorMessage = document.getElementById("errorMessage");

    function log(...args) { logEl.textContent += args.map(String).join(" ") + "\n"; }
    function showLoading(msg) { loadingMessage.style.display = "block"; loadingMessage.textContent = msg; }
    function hideLoading() { loadingMessage.style.display = "none"; }
    function showError(msg) { errorMessage.style.display = "block"; errorMessage.textContent = msg; }
    function hideError() { errorMessage.style.display = "none"; }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // ---------------- CONFIG ----------------
    const projectId = "19acc37cc9d91b4b39b0cca952297654";

    const RELAYS = ["wss://relay.walletconnect.com", "wss://relay.walletconnect.org"];
    let relayIdx = 0;

    const SEPOLIA = 11155111;
    const SEPOLIA_HEX = "0xaa36a7";
    const SEPOLIA_RPC_PRIMARY = "https://rpc.sepolia.org";
    const SEPOLIA_RPC_SECONDARY = "https://rpc2.sepolia.org";
    const SEPOLIA_EXPLORER = "https://sepolia.etherscan.io";

    // Recipient (Account 1)
    const TO_ADDRESS = "0x789c7d1f7dfef60a00ff6f7a87ba426bde521b08";
    // 0.0006 ETH in wei
    const TEST_VALUE_WEI = "600000000000000";

    // ---------------- PAGE INSTANCE + RESUME ----------------
    const PAGE_INSTANCE_ID = (crypto?.randomUUID?.() ?? (Date.now().toString(36) + Math.random().toString(36).slice(2)));
    const FLOW_KEY = "wc_onebutton_flow_v2";
    const FLOW_TTL_MS = 10 * 60 * 1000;

    function loadFlow() {
      try {
        const raw = localStorage.getItem(FLOW_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || !obj.inProgress) return null;
        if ((Date.now() - (obj.updatedAt || 0)) > FLOW_TTL_MS) {
          localStorage.removeItem(FLOW_KEY);
          return null;
        }
        return obj;
      } catch {
        return null;
      }
    }

    function saveFlow(patch) {
      const cur = loadFlow() || {};
      const next = { ...cur, ...patch, updatedAt: Date.now() };
      localStorage.setItem(FLOW_KEY, JSON.stringify(next));
    }

    function clearFlow() {
      localStorage.removeItem(FLOW_KEY);
    }

    log("PAGE_INSTANCE_ID:", PAGE_INSTANCE_ID);

    // ---------------- STATE ----------------
    let provider = null;
    let wcUri = null;

    let busy = false;
    let connectInFlight = false;
    let openedMmThisAttempt = false;

    // last known values from events
    let lastAccounts = [];
    let lastChainId = null; // string like "0xaa36a7"

    function isRelayishError(e) {
      const msg = String((e && (e.message ?? e)) ?? "");
      return (
        msg.includes("relay") ||
        msg.includes("socket connection") ||
        msg.includes("ERR_NAME_NOT_RESOLVED") ||
        msg.includes("Couldn't establish socket") ||
        msg.includes("Failed to fetch")
      );
    }

    function openMetaMaskViaWcUri(reason = "") {
      if (!wcUri) return;
      if (openedMmThisAttempt) return; // open only once per attempt
      openedMmThisAttempt = true;

      const uri = encodeURIComponent(wcUri);
      const universalLink = `https://metamask.app.link/wc?uri=${uri}`;

      saveFlow({ stage: "awaiting_approval" });
      log("Opening MetaMask", reason ? `| ${reason}` : "");
      log(universalLink);
      location.href = universalLink;
    }

    async function teardownProvider() {
      try { await provider?.disconnect?.(); } catch (_) {}
      provider = null;
      wcUri = null;
      connectInFlight = false;
      openedMmThisAttempt = false;
      lastAccounts = [];
      lastChainId = null;
    }

    async function ensureProvider() {
      if (provider) return provider;

      const WC = window["@walletconnect/ethereum-provider"];
      if (!WC?.EthereumProvider) throw new Error("WalletConnect EthereumProvider not loaded");

      const relayUrl = RELAYS[relayIdx];

      provider = await WC.EthereumProvider.init({
        projectId,
        relayUrl,
        showQrModal: false,
        metadata: {
          name: "WC + ethers One Button",
          description: "Android Chrome -> MetaMask approve -> JS signer (ethers)",
          url: location.origin,
          icons: ["https://metamask.io/images/favicon-32.png"],
        },
        chains: [SEPOLIA],
        optionalChains: [SEPOLIA],
        rpcMap: { [SEPOLIA]: SEPOLIA_RPC_PRIMARY },
      });

      provider.on("display_uri", (uri) => {
        wcUri = uri;
        log("display_uri ready");
        if (connectInFlight) openMetaMaskViaWcUri("display_uri during connect()");
      });

      provider.on("connect", (info) => log("connected:", JSON.stringify(info)));

      provider.on("disconnect", () => {
        log("disconnected");
        wcUri = null;
        connectInFlight = false;
        openedMmThisAttempt = false;
        lastAccounts = [];
        lastChainId = null;
      });

      provider.on("accountsChanged", (accounts) => {
        lastAccounts = Array.isArray(accounts) ? accounts : [];
        log("accountsChanged:", JSON.stringify(lastAccounts));
      });

      provider.on("chainChanged", (chainId) => {
        lastChainId = String(chainId).toLowerCase();
        log("chainChanged:", lastChainId);
      });

      log("Using relay:", relayUrl);
      return provider;
    }

    async function waitFor(fn, { timeoutMs = 90000, intervalMs = 400, label = "condition" } = {}) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          if (await fn()) return true;
        } catch (_) {}
        await sleep(intervalMs);
      }
      throw new Error(`Timed out waiting for ${label} (${Math.round(timeoutMs/1000)}s).`);
    }

    // Connect logic:
    // - If session already authorized (eth_accounts non-empty), reuse (important for "Chrome reloaded" cases)
    // - BUT if that account equals TO_ADDRESS, force fresh connect so you can choose a different account.
    async function connectWithRelayFallback() {
      await ensureProvider();

      if (provider?.session) {
        const existing = await provider.request({ method: "eth_accounts" }).catch(() => []);
        if (Array.isArray(existing) && existing[0]) {
          lastAccounts = existing;
          log("WC session already authorized. Reusing ✅");

          if (String(existing[0]).toLowerCase() !== TO_ADDRESS.toLowerCase()) {
            saveFlow({ stage: "connected_reused" });
            return; // reuse is safe
          }

          log("Authorized account == recipient. Forcing fresh connect so you can pick Account 2…");
        } else {
          log("WC session present but no authorized account yet.");
        }

        // Force fresh permission prompt
        log("Disconnecting existing WC session to request permissions again…");
        try { await provider.disconnect(); } catch (_) {}
        wcUri = null;
        lastAccounts = [];
        lastChainId = null;
      }

      openedMmThisAttempt = false;
      connectInFlight = true;
      saveFlow({ stage: "connecting" });

      try {
        const connectPromise = provider.connect();

        // If display_uri already arrived, open MetaMask once shortly after connect begins.
        setTimeout(() => {
          if (!connectInFlight) return;
          if (wcUri) openMetaMaskViaWcUri("connect() started");
        }, 350);

        // Optional single nudge ONLY if still no account after a while
        setTimeout(() => {
          if (!connectInFlight) return;
          if (wcUri && !(Array.isArray(lastAccounts) && lastAccounts[0])) {
            openMetaMaskViaWcUri("nudge (no account yet)");
          }
        }, 4000);

        await connectPromise;
        saveFlow({ stage: "connected" });
      } catch (e) {
        if (!isRelayishError(e)) throw e;

        log("Relay seems unreachable. Trying fallback relay…");
        await teardownProvider();
        relayIdx = (relayIdx + 1) % RELAYS.length;

        await ensureProvider();
        return connectWithRelayFallback();
      } finally {
        connectInFlight = false;
      }
    }

    async function getChainIdHex() {
      const c = await provider.request({ method: "eth_chainId" });
      return String(c).toLowerCase();
    }

    // Sepolia settle window:
    // - After connect, give the wallet a moment to "settle" before we request a switch.
    // - This reduces pointless switch prompts and reduces delays.
    async function ensureSepoliaNetwork() {
      showLoading("Ensuring Sepolia…");
      saveFlow({ stage: "ensuring_sepolia" });

      // Fast path from events
      if (lastChainId === SEPOLIA_HEX) {
        log("Already on Sepolia ✅ (from event)");
        hideLoading();
        return;
      }

      // Settle window (no prompts)
      showLoading("Checking network (settling)…");
      const settleUntil = Date.now() + 4500;
      while (Date.now() < settleUntil) {
        if (lastChainId === SEPOLIA_HEX) {
          log("Already on Sepolia ✅ (settled via event)");
          hideLoading();
          return;
        }
        const c = await getChainIdHex().catch(() => null);
        if (c === SEPOLIA_HEX) {
          log("Already on Sepolia ✅ (settled via request)");
          hideLoading();
          return;
        }
        await sleep(450);
      }

      // Still not Sepolia, request switch
      const currentHex = await getChainIdHex();
      log("current chainId:", currentHex);

      if (currentHex === SEPOLIA_HEX) {
        log("Already on Sepolia ✅");
        hideLoading();
        return;
      }

      showLoading("Approve network switch to Sepolia in MetaMask…");
      saveFlow({ stage: "switch_prompted" });

      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: SEPOLIA_HEX }],
        });
        log("Switch requested ✅");
      } catch (e) {
        const code = e && (e.code ?? e?.data?.originalError?.code);
        log("switch error:", e?.message || e);

        if (code === 4902) {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: SEPOLIA_HEX,
              chainName: "Sepolia",
              nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
              rpcUrls: [SEPOLIA_RPC_PRIMARY, SEPOLIA_RPC_SECONDARY],
              blockExplorerUrls: [SEPOLIA_EXPLORER],
            }],
          });
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: SEPOLIA_HEX }],
          });
          log("Added + switch requested ✅");
        } else {
          throw e;
        }
      }

      // Wait until it truly settles to Sepolia
      showLoading("Waiting for Sepolia to settle…");
      await waitFor(async () => {
        if (lastChainId === SEPOLIA_HEX) return true;
        const c = await getChainIdHex().catch(() => null);
        return c === SEPOLIA_HEX;
      }, { timeoutMs: 90000, intervalMs: 500, label: "Sepolia chainId" });

      log("Switched to Sepolia ✅");
      hideLoading();
      saveFlow({ stage: "sepolia_ready" });
    }

    async function getAuthorizedAccount() {
      const a0 = Array.isArray(lastAccounts) && lastAccounts[0] ? lastAccounts[0] : null;
      if (a0) return a0;

      try {
        const req = await provider.request({ method: "eth_requestAccounts" });
        if (Array.isArray(req) && req[0]) return req[0];
      } catch (e) {
        log("eth_requestAccounts error:", e?.message || e);
      }

      showLoading("Waiting for MetaMask account approval…");
      await waitFor(async () => {
        const a = Array.isArray(lastAccounts) && lastAccounts[0] ? lastAccounts[0] : null;
        if (a) return true;

        const ea = await provider.request({ method: "eth_accounts" }).catch(() => []);
        if (Array.isArray(ea) && ea[0]) { lastAccounts = ea; return true; }
        return false;
      }, { timeoutMs: 90000, intervalMs: 500, label: "authorized account" });

      hideLoading();
      return lastAccounts[0];
    }

    async function sendTestTxFromJS() {
      saveFlow({ stage: "sending_tx" });

      // Hard gate: do NOT send until chain truly equals Sepolia
      await waitFor(async () => {
        if (lastChainId === SEPOLIA_HEX) return true;
        const c = await getChainIdHex().catch(() => null);
        return c === SEPOLIA_HEX;
      }, { timeoutMs: 30000, intervalMs: 500, label: "Sepolia at send-time" });

      const account = await getAuthorizedAccount();

      const ethersProvider = new ethers.BrowserProvider(provider);
      const signer = await ethersProvider.getSigner(account);

      log("signer:", account);
      log("to:", TO_ADDRESS);
      log("valueWei:", TEST_VALUE_WEI);

      showLoading("Approve transaction in MetaMask…");

      const tx = await signer.sendTransaction({
        to: TO_ADDRESS,
        value: BigInt(TEST_VALUE_WEI),
      });

      log("tx sent:", tx.hash);
      log("Etherscan:", `${SEPOLIA_EXPLORER}/tx/${tx.hash}`);
      hideLoading();

      saveFlow({ stage: "done" });
      clearFlow();
    }

    async function runFlow({ resume = false } = {}) {
      if (busy) return;
      busy = true;

      btnDoIt.disabled = true;
      hideError();

      if (!resume) logEl.textContent = "";

      try {
        if (!resume) {
          saveFlow({ inProgress: true, stage: "start", startedAt: Date.now(), pageInstance: PAGE_INSTANCE_ID });
        } else {
          // keep existing stage; just mark we tried
          saveFlow({ inProgress: true });
        }

        showLoading("Connecting wallet…");
        log("Tap MetaMask approvals when prompted, then return to Chrome if needed.");

        await connectWithRelayFallback();
        await ensureSepoliaNetwork();
        await sendTestTxFromJS();

      } catch (e) {
        hideLoading();
        const msg = String(e?.message || e);
        log("error:", msg);
        showError(msg);

        // Keep flow marker so returning to Chrome can resume
        saveFlow({ inProgress: true, stage: loadFlow()?.stage || "error_waiting" });

        log("If MetaMask opened, approve prompts then come back and tap the SAME button again.");
      } finally {
        btnDoIt.disabled = false;
        busy = false;
      }
    }

    // Button
    btnDoIt.onclick = async () => {
      await runFlow({ resume: false });
    };

    // Resume strategy:
    // - If Chrome reloads after app switch, we can continue without forcing a brand-new handshake.
    let lastResumeAttempt = 0;
    async function maybeResume(trigger) {
      const st = loadFlow();
      if (!st || !st.inProgress) return;
      if (busy) return;

      // throttle resume attempts
      if (Date.now() - lastResumeAttempt < 1200) return;
      lastResumeAttempt = Date.now();

      log(`Resume check (${trigger}) stage=${st.stage} savedPage=${st.pageInstance || "?"} nowPage=${PAGE_INSTANCE_ID}`);
      await runFlow({ resume: true });
    }

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) maybeResume("visibilitychange");
    });

    // Also try once shortly after load
    setTimeout(() => maybeResume("onload"), 300);
  </script>
</body>
</html>

