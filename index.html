<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WC + ethers (One Button)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    button { font-size: 18px; padding: 14px 18px; border-radius: 10px; border: 1px solid #bbb; background: #f7f7f7; }
    button:disabled { opacity: 0.5; }
    #log { margin-top: 14px; white-space: pre-wrap; }
    #loadingMessage, #errorMessage { margin-top: 10px; }

    /* Wallet picker modal (added) */
    #walletPickerOverlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 14px;
    }
    #walletPicker {
      width: min(520px, 100%);
      max-height: min(78vh, 700px);
      background: #111;
      color: #fff;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
    }
    #walletPickerHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #walletPickerHeader strong { font-size: 16px; }
    #walletPickerClose {
      font-size: 18px;
      line-height: 1;
      padding: 8px 10px;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      cursor: pointer;
    }
    #walletPickerBody { padding: 12px; display: flex; flex-direction: column; gap: 10px; }
    #walletSearch {
      width: 100%;
      font-size: 16px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #fff;
      outline: none;
    }
    #walletList {
      overflow: auto;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      padding-bottom: 6px;
    }
    .walletRow {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor: pointer;
      user-select: none;
    }
    .walletRow:active { transform: scale(0.99); }
    .walletLogo {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      flex: 0 0 auto;
      object-fit: cover;
    }
    .walletMeta { display: flex; flex-direction: column; gap: 2px; }
    .walletName { font-size: 15px; font-weight: 650; }
    .walletHint { font-size: 12px; opacity: 0.75; }
    #walletPickerFooter {
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      opacity: 0.85;
    }
    #walletPickerFooter code { opacity: 0.95; word-break: break-all; }
  </style>
</head>

<body>
  <button id="btnDoIt">Send Test Tx (from JS)</button>
  <div id="loadingMessage" style="display:none;">Working…</div>
  <div id="errorMessage" style="display:none; color: red;"></div>
  <pre id="log"></pre>

  <!-- Wallet picker modal (added) -->
  <div id="walletPickerOverlay">
    <div id="walletPicker">
      <div id="walletPickerHeader">
        <strong>Choose a wallet</strong>
        <button id="walletPickerClose" type="button">✕</button>
      </div>
      <div id="walletPickerBody">
        <input id="walletSearch" placeholder="Search wallet (MetaMask, Trust, Coinbase…)" />
        <div id="walletList"></div>
      </div>
      <div id="walletPickerFooter">
        Listings from <code>explorer-api.walletconnect.com</code>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.23.3/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

  <script>
    // ---------------- UI ----------------
    const logEl = document.getElementById("log");
    const btnDoIt = document.getElementById("btnDoIt");
    const loadingMessage = document.getElementById("loadingMessage");
    const errorMessage = document.getElementById("errorMessage");

    // wallet picker elements (added)
    const walletPickerOverlay = document.getElementById("walletPickerOverlay");
    const walletPickerClose = document.getElementById("walletPickerClose");
    const walletSearch = document.getElementById("walletSearch");
    const walletListEl = document.getElementById("walletList");

    function log(...args) { logEl.textContent += args.map(String).join(" ") + "\n"; }
    function showLoading(msg) { loadingMessage.style.display = "block"; loadingMessage.textContent = msg; }
    function hideLoading() { loadingMessage.style.display = "none"; }
    function showError(msg) { errorMessage.style.display = "block"; errorMessage.textContent = msg; }
    function hideError() { errorMessage.style.display = "none"; }

    function openWalletPicker() { walletPickerOverlay.style.display = "flex"; }
    function closeWalletPicker() { walletPickerOverlay.style.display = "none"; }
    walletPickerClose.onclick = closeWalletPicker;
    walletPickerOverlay.addEventListener("click", (e) => {
      if (e.target === walletPickerOverlay) closeWalletPicker();
    });

    // ---------------- CONFIG (state-0) ----------------
    const projectId = "19acc37cc9d91b4b39b0cca952297654";

    const RELAYS = ["wss://relay.walletconnect.com", "wss://relay.walletconnect.org"];
    let relayIdx = 0;

    const SEPOLIA = 11155111;
    const SEPOLIA_HEX = "0xaa36a7";
    const SEPOLIA_RPC_PRIMARY = "https://eth-sepolia.g.alchemy.com/v2/7meoZAwbjWt6m9on3Phcy";
    const SEPOLIA_RPC_SECONDARY = "https://ethereum-sepolia.publicnode.com";
    const SEPOLIA_EXPLORER = "https://sepolia.etherscan.io";

    const TO_ADDRESS = "0x789c7d1f7dfef60a00ff6f7a87ba426bde521b08";
    const TEST_VALUE_WEI = "600000000000000"; // 0.0006

    // ---------------- STATE (state-0) ----------------
    let provider = null;
    let wcUri = null;

    let busy = false;
    let connectInFlight = false;
    let openedMmThisAttempt = false;

    let lastAccounts = [];
    let lastChainId = null;

    // wallet picker state (added)
    let walletsCache = null;

    function normalizeChainIdToHex(chainId) {
      if (typeof chainId === "number") return ("0x" + chainId.toString(16)).toLowerCase();
      const s = String(chainId).trim().toLowerCase();
      if (s.startsWith("0x")) return s;
      if (/^\d+$/.test(s)) return ("0x" + Number(s).toString(16)).toLowerCase();
      return s;
    }

    function isRelayishError(e) {
      const msg = String((e && (e.message ?? e)) ?? "");
      return (
        msg.includes("relay") ||
        msg.includes("socket connection") ||
        msg.includes("ERR_NAME_NOT_RESOLVED") ||
        msg.includes("Couldn't establish socket") ||
        msg.includes("Failed to fetch")
      );
    }

    // ---------------- Wallet Choice Persistence (added) ----------------
    const WALLET_CHOICE_KEY = "wc_wallet_choice_v1";
    function getSavedWalletChoice() {
      try {
        const raw = localStorage.getItem(WALLET_CHOICE_KEY);
        if (!raw) return null;
        const j = JSON.parse(raw);
        if (!j || !j.base) return null;
        return j;
      } catch (_) { return null; }
    }
    function saveWalletChoice(choice) {
      try { localStorage.setItem(WALLET_CHOICE_KEY, JSON.stringify(choice)); } catch (_) {}
    }

    function isAndroid() {
      return /Android/i.test(navigator.userAgent || "");
    }

    function logoUrl(imageId) {
      if (!imageId) return "";
      return `https://explorer-api.walletconnect.com/v3/logo/md/${encodeURIComponent(imageId)}?projectId=${encodeURIComponent(projectId)}`;
    }

    function normalizeWalletsResponse(json) {
      const listings = json?.listings ?? json?.data ?? json;
      const arr = Array.isArray(listings) ? listings : Object.values(listings || {});
      return arr.filter(Boolean);
    }

    async function fetchWallets() {
      if (walletsCache) return walletsCache;

      const platforms = isAndroid() ? "android" : "ios";
      const url =
        `https://explorer-api.walletconnect.com/v3/wallets` +
        `?projectId=${encodeURIComponent(projectId)}` +
        `&entries=40&page=1` +
        `&platforms=${encodeURIComponent(platforms)}` +
        `&sdks=sign_v2`;

      // timeout so UI doesn't hang forever
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), 8000);

      const res = await fetch(url, { mode: "cors", signal: controller.signal });
      clearTimeout(t);

      if (!res.ok) throw new Error(`Explorer API failed (${res.status})`);
      const json = await res.json();

      let wallets = normalizeWalletsResponse(json);

      wallets = wallets.filter(w =>
        w?.mobile?.universal || w?.mobile?.native || w?.desktop?.universal || w?.desktop?.native
      );

      // MetaMask first
      wallets.sort((a, b) => {
        const an = String(a?.name || "").toLowerCase();
        const bn = String(b?.name || "").toLowerCase();
        const as = (an === "metamask") ? -1 : 0;
        const bs = (bn === "metamask") ? -1 : 0;
        if (as !== bs) return as - bs;
        return an.localeCompare(bn);
      });

      walletsCache = wallets;
      return walletsCache;
    }

    // ✅ FIXED: always inject current wcUri, never return stale base
    function buildWcDeepLink(base, uri) {
      if (!base || !uri) return null;

      const baseStr = String(base);

      // MetaMask: harden (prevents "page doesn't exist" due to listing weirdness)
      if (baseStr.includes("metamask.app.link")) {
        return `https://metamask.app.link/wc?uri=${encodeURIComponent(uri)}`;
      }

      // HTTP(s): set/replace ?uri=
      if (baseStr.startsWith("http")) {
        try {
          const u = new URL(baseStr);
          u.searchParams.set("uri", uri);
          return u.toString();
        } catch (_) {
          // fallback below
        }
      }

      const enc = encodeURIComponent(uri);

      // if base already contains uri=..., replace it
      if (baseStr.includes("uri=")) {
        return baseStr.replace(/uri=[^&]*/i, `uri=${enc}`);
      }

      // Native schemes
      if (baseStr.endsWith(":")) return `${baseStr}//wc?uri=${enc}`;
      if (baseStr.includes("://")) return `${baseStr}wc?uri=${enc}`;
      return null;
    }

    // More reliable MetaMask open (scheme first, fallback to universal)
    function openMetaMaskUniversalOrNative(universalLink) {
      const m = universalLink.match(/^https:\/\/metamask\.app\.link\/wc\?uri=(.+)$/i);
      if (!m) {
        location.href = universalLink;
        return;
      }
      const uriEnc = m[1];
      const nativeLink = `metamask://wc?uri=${uriEnc}`;

      // try native first
      location.href = nativeLink;

      // fallback
      setTimeout(() => {
        location.href = universalLink;
      }, 700);
    }

    // state-0 function name preserved: now opens either chosen wallet or defaults to MetaMask
    function openMetaMaskViaWcUri(reason = "") {
      if (!wcUri) return;
      if (openedMmThisAttempt) return; // open once
      openedMmThisAttempt = true;

      const saved = getSavedWalletChoice();
      let link = null;

      if (saved?.base) {
        link = buildWcDeepLink(saved.base, wcUri);
      }

      // default MetaMask link if no saved wallet
      if (!link) link = `https://metamask.app.link/wc?uri=${encodeURIComponent(wcUri)}`;

      log("Opening wallet", reason ? `| ${reason}` : "");
      log(link);

      if (String(link).startsWith("https://metamask.app.link/wc?uri=")) {
        openMetaMaskUniversalOrNative(link);
      } else {
        location.href = link;
      }
    }

    function renderWalletList(wallets, filterText = "") {
      const q = String(filterText || "").trim().toLowerCase();
      const filtered = q ? wallets.filter(w => String(w?.name || "").toLowerCase().includes(q)) : wallets;

      walletListEl.innerHTML = "";

      if (!filtered.length) {
        walletListEl.innerHTML = `<div style="opacity:.85;padding:8px">No wallets matched.</div>`;
        return;
      }

      for (const w of filtered.slice(0, 30)) {
        const row = document.createElement("div");
        row.className = "walletRow";

        const img = document.createElement("img");
        img.className = "walletLogo";
        img.alt = w?.name || "wallet";
        const src = logoUrl(w?.image_id);
        if (src) img.src = src;

        const meta = document.createElement("div");
        meta.className = "walletMeta";

        const name = document.createElement("div");
        name.className = "walletName";
        name.textContent = w?.name || "Unknown wallet";

        const hint = document.createElement("div");
        hint.className = "walletHint";
        hint.textContent = "Tap once to select (future connects won’t ask again)";

        meta.appendChild(name);
        meta.appendChild(hint);

        row.appendChild(img);
        row.appendChild(meta);

        row.onclick = () => {
          if (!wcUri) return;

          const nm = String(w?.name || "");
          const base =
            w?.mobile?.universal ||
            w?.mobile?.native ||
            w?.desktop?.universal ||
            w?.desktop?.native ||
            "";

          // Persist choice
          const chosenBase = nm.toLowerCase() === "metamask"
            ? "https://metamask.app.link/wc"
            : String(base);

          saveWalletChoice({ name: nm, base: chosenBase });

          closeWalletPicker();

          // Open immediately (user gesture)
          openedMmThisAttempt = false; // allow open now
          openMetaMaskViaWcUri(`picked: ${nm}`);
        };

        walletListEl.appendChild(row);
      }
    }

    async function showWalletChoices() {
      const wallets = await fetchWallets();
      walletSearch.value = "";
      walletSearch.oninput = () => renderWalletList(wallets, walletSearch.value);
      renderWalletList(wallets, "");
      openWalletPicker();
    }

    // ---------------- state-0 provider lifecycle ----------------
    async function teardownProvider() {
      try { await provider?.disconnect?.(); } catch (_) {}
      provider = null;
      wcUri = null;
      connectInFlight = false;
      openedMmThisAttempt = false;
      lastAccounts = [];
      lastChainId = null;
    }

    async function ensureProvider() {
      if (provider) return provider;

      const WC = window["@walletconnect/ethereum-provider"];
      if (!WC?.EthereumProvider) throw new Error("WalletConnect EthereumProvider not loaded");

      const relayUrl = RELAYS[relayIdx];

      provider = await WC.EthereumProvider.init({
        projectId,
        relayUrl,
        showQrModal: false,
        metadata: {
          name: "WC + ethers One Button",
          description: "Android Chrome -> Wallet approve -> JS signer (ethers)",
          url: location.origin,
          icons: ["https://metamask.io/images/favicon-32.png"],
        },
        chains: [SEPOLIA],
        optionalChains: [SEPOLIA],
        rpcMap: { [SEPOLIA]: SEPOLIA_RPC_PRIMARY },
      });

      provider.on("display_uri", async (uri) => {
        wcUri = uri;
        log("display_uri ready");

        if (!connectInFlight) return;

        const saved = getSavedWalletChoice();
        if (saved?.base) {
          // Do NOT show picker again
          openMetaMaskViaWcUri("saved wallet");
          return;
        }

        // First time only
        try {
          await showWalletChoices();
        } catch (e) {
          log("wallet list error:", e?.message || e);
          // fallback picker shows only MetaMask
          renderWalletList([{ name: "MetaMask", image_id: null, mobile: { universal: "https://metamask.app.link/wc" }}], "");
          openWalletPicker();
        }
      });

      provider.on("connect", (info) => log("connected:", JSON.stringify(info)));

      provider.on("disconnect", () => {
        log("disconnected");
        wcUri = null;
        connectInFlight = false;
        openedMmThisAttempt = false;
        lastAccounts = [];
        lastChainId = null;
      });

      provider.on("accountsChanged", (accounts) => {
        lastAccounts = Array.isArray(accounts) ? accounts : [];
        log("accountsChanged:", JSON.stringify(lastAccounts));
      });

      provider.on("chainChanged", (chainId) => {
        lastChainId = normalizeChainIdToHex(chainId);
        log("chainChanged:", lastChainId);
      });

      log("Using relay:", relayUrl);
      return provider;
    }

    async function waitFor(fn, { timeoutMs = 90000, intervalMs = 400, label = "condition" } = {}) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try { if (await fn()) return true; } catch (_) {}
        await new Promise(r => setTimeout(r, intervalMs));
      }
      throw new Error(`Timed out waiting for ${label} (${Math.round(timeoutMs/1000)}s).`);
    }

    // ---------------- state-0 flow (UNCHANGED) ----------------
    async function connectWithRelayFallback() {
      await ensureProvider();

      if (provider?.session) {
        log("Existing WC session found. Disconnecting to avoid stale account/session…");
        try { await provider.disconnect(); } catch (_) {}
        wcUri = null;
        lastAccounts = [];
        lastChainId = null;
      }

      openedMmThisAttempt = false;
      connectInFlight = true;

      try {
        await provider.connect();
      } catch (e) {
        if (!isRelayishError(e)) throw e;

        log("Relay seems unreachable. Trying fallback relay…");
        await teardownProvider();
        relayIdx = (relayIdx + 1) % RELAYS.length;

        await ensureProvider();
        return connectWithRelayFallback();
      } finally {
        connectInFlight = false;
      }
    }

    async function ensureSepoliaNetwork() {
      showLoading("Ensuring Sepolia…");

      const readChain = async () => normalizeChainIdToHex(await provider.request({ method: "eth_chainId" }));

      let current = await readChain();
      log("current chainId:", current);

      if (current === SEPOLIA_HEX) {
        log("Already on Sepolia ✅");
        hideLoading();
        return;
      }

      showLoading("Approve network switch to Sepolia in wallet…");
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: SEPOLIA_HEX }],
        });
        log("Switch requested ✅");
      } catch (e) {
        const code = e && (e.code ?? e?.data?.originalError?.code);
        log("switch error:", e?.message || e);

        if (code === 4902) {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: SEPOLIA_HEX,
              chainName: "Sepolia",
              nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
              rpcUrls: [SEPOLIA_RPC_PRIMARY, SEPOLIA_RPC_SECONDARY],
              blockExplorerUrls: [SEPOLIA_EXPLORER],
            }],
          });

          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: SEPOLIA_HEX }],
          });

          log("Added + switched requested ✅");
        } else {
          throw e;
        }
      }

      showLoading("Waiting for Sepolia to settle…");
      await waitFor(async () => (await readChain()) === SEPOLIA_HEX, {
        timeoutMs: 90000,
        intervalMs: 500,
        label: "Sepolia chainId via eth_chainId"
      });

      log("Switched to Sepolia ✅");
      hideLoading();
    }

    async function getAuthorizedAccount() {
      const a0 = Array.isArray(lastAccounts) && lastAccounts[0] ? lastAccounts[0] : null;
      if (a0) return a0;

      try {
        const req = await provider.request({ method: "eth_requestAccounts" });
        if (Array.isArray(req) && req[0]) return req[0];
      } catch (e) {
        log("eth_requestAccounts error:", e?.message || e);
      }

      showLoading("Waiting for wallet account approval…");
      await waitFor(async () => {
        const a = Array.isArray(lastAccounts) && lastAccounts[0] ? lastAccounts[0] : null;
        if (a) return true;
        const ea = await provider.request({ method: "eth_accounts" }).catch(() => []);
        if (Array.isArray(ea) && ea[0]) { lastAccounts = ea; return true; }
        return false;
      }, { timeoutMs: 90000, intervalMs: 500, label: "authorized account" });

      hideLoading();
      return lastAccounts[0];
    }

    async function sendTestTxFromJS() {
      const account = await getAuthorizedAccount();

      // ✅ HARD STOP: if we are not on Sepolia, we do NOT attempt a tx
      const chainNow = normalizeChainIdToHex(await provider.request({ method: "eth_chainId" }));
      log("chainId (pre-tx):", chainNow);

      if (chainNow !== SEPOLIA_HEX) {
        throw new Error(`Not on Sepolia (chainId=${chainNow}). Not sending from Mainnet. Approve the Sepolia switch in wallet, then tap the button again.`);
      }

      const ethersProvider = new ethers.BrowserProvider(provider);
      const signer = await ethersProvider.getSigner(account);

      log("signer:", account);
      log("to:", TO_ADDRESS);
      log("valueWei:", TEST_VALUE_WEI);

      // --- balance test kept ---
      const balHex = await provider.request({ method: "eth_getBalance", params: [account, "latest"] });
      const balWeiRpc = BigInt(balHex);
      log("balanceHex (eth_getBalance):", balHex);
      log("balanceWei (eth_getBalance):", balWeiRpc.toString());
      log("balanceETH (eth_getBalance):", ethers.formatEther(balWeiRpc));

      const balWeiEthers = await ethersProvider.getBalance(account);
      log("balanceWei (ethers.getBalance):", balWeiEthers.toString());
      log("balanceETH (ethers.getBalance):", ethers.formatEther(balWeiEthers));

      showLoading("Approve transaction in wallet…");
      const tx = await signer.sendTransaction({
        to: TO_ADDRESS,
        value: BigInt(TEST_VALUE_WEI),
      });

      log("tx sent:", tx.hash);
      log("Etherscan:", `${SEPOLIA_EXPLORER}/tx/${tx.hash}`);
      hideLoading();
    }

    btnDoIt.onclick = async () => {
      if (busy) return;
      busy = true;

      btnDoIt.disabled = true;
      logEl.textContent = "";
      hideError();

      try {
        showLoading("Connecting wallet…");
        log("Approvals happen in the wallet app. Return to Chrome when done.");

        await connectWithRelayFallback();
        await ensureSepoliaNetwork();
        await sendTestTxFromJS();

      } catch (e) {
        hideLoading();
        const msg = String(e?.message || e);
        log("error:", msg);
        showError(msg);
        log("If the wallet opened, approve prompts then come back and tap the SAME button again.");
      } finally {
        btnDoIt.disabled = false;
        busy = false;
      }
    };
  </script>
</body>
</html>
