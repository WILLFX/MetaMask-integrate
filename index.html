<!doctype html>
<html>
  <body>
    <button id="btnConnect">Connect</button>
    <button id="btnOpenMM" disabled>Open MetaMask</button>
    <button id="btnDisconnect" disabled>Disconnect</button>

    <pre id="log"></pre>

    <!-- WalletConnect v2 EthereumProvider (UMD build, no bundler) -->
    <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.23.3/dist/index.umd.js"></script>

    <script>
      const logEl = document.getElementById("log");
      const btnConnect = document.getElementById("btnConnect");
      const btnOpenMM = document.getElementById("btnOpenMM");
      const btnDisconnect = document.getElementById("btnDisconnect");

      function log(...args) {
        logEl.textContent += args.map(String).join(" ") + "\n";
      }

      // ---- CONFIG ----
      const projectId = "19acc37cc9d91b4b39b0cca952297654";

      // Sepolia chain id (we won't do the demo call yet, but we can request Sepolia)
      const SEPOLIA = 11155111;
      const SEPOLIA_RPC = "https://rpc.sepolia.org";

      // ---- STATE ----
      let provider = null;
      let wcUri = null;

      async function ensureProvider() {
        if (provider) return provider;

        const WC = window["@walletconnect/ethereum-provider"];
        if (!WC?.EthereumProvider) throw new Error("WalletConnect EthereumProvider not loaded");

        provider = await WC.EthereumProvider.init({
          projectId,
          showQrModal: false,

          // This matters on GitHub Pages, keep it consistent with where you're hosting
          metadata: {
            name: "Bare WC Demo",
            description: "WalletConnect v2 bare HTML",
            url: location.origin,
            icons: ["https://metamask.io/images/favicon-32.png"]
          },

          optionalChains: [SEPOLIA],
          rpcMap: { [SEPOLIA]: SEPOLIA_RPC }
        });

        provider.on("display_uri", (uri) => {
          wcUri = uri;
          log("display_uri ready");

          // Enable the "Open MetaMask" button once we have the URI
          btnOpenMM.disabled = false;
        });

        provider.on("connect", (info) => {
          log("connected:", JSON.stringify(info));
          btnDisconnect.disabled = false;
        });

        provider.on("disconnect", () => {
          log("disconnected");
          btnOpenMM.disabled = true;
          btnDisconnect.disabled = true;
          wcUri = null;
        });

        provider.on("accountsChanged", (accounts) => {
          log("accountsChanged:", JSON.stringify(accounts));
        });

        provider.on("chainChanged", (chainId) => {
          log("chainChanged:", String(chainId));
        });

        return provider;
      }

      async function showAccounts() {
        const accounts = await provider.request({ method: "eth_accounts" });
        if (accounts && accounts[0]) log("account:", accounts[0]);
        else log("account: (none yet)");
      }

      btnConnect.onclick = async () => {
        try {
          await ensureProvider();

          log("Starting connection. After you tap 'Open MetaMask', approve, then return here.");
          // This will trigger display_uri; it resolves only after approval in wallet
          await provider.connect();

          await showAccounts();
          btnDisconnect.disabled = false;
        } catch (e) {
          log("connect error:", e?.message || e);
        }
      };

      btnOpenMM.onclick = () => {
        if (!wcUri) return;

        // Prefer universal link (https navigation is friendlier in Chrome)
        const universal = "https://metamask.app.link/wc?uri=" + encodeURIComponent(wcUri);
        log("Opening MetaMask via:", universal);

        // User-gesture navigation (no auto redirects)
        location.href = universal;
      };

      btnDisconnect.onclick = async () => {
        try {
          if (!provider) return;
          await provider.disconnect();
        } catch (e) {
          log("disconnect error:", e?.message || e);
        }
      };

      // Optional: on reload, try to restore an existing session
      (async () => {
        try {
          await ensureProvider();
          // If a session exists, accounts will show without re-pairing
          await showAccounts();
        } catch (_) {}
      })();
    </script>
  </body>
</html>




