<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WC + ethers (One Button)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 16px; }
    button {
      font-size: 18px;
      padding: 14px 18px;
      border-radius: 10px;
      border: 1px solid #bbb;
      background: #f7f7f7;
    }
    button:disabled { opacity: 0.5; }
    #log { margin-top: 14px; white-space: pre-wrap; }
    #loadingMessage, #errorMessage { margin-top: 10px; }
  </style>
</head>

<body>
  <button id="btnDoIt">Send Test Tx (from JS)</button>

  <div id="loadingMessage" style="display:none;">Working…</div>
  <div id="errorMessage" style="display:none; color: red;"></div>
  <pre id="log"></pre>

  <!-- WalletConnect Ethereum Provider (v2) -->
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.23.3/dist/index.umd.js"></script>

  <!-- ethers v6 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

  <script>
    // ---------------- UI ----------------
    const logEl = document.getElementById("log");
    const btnDoIt = document.getElementById("btnDoIt");
    const loadingMessage = document.getElementById("loadingMessage");
    const errorMessage = document.getElementById("errorMessage");

    function log(...args) { logEl.textContent += args.map(String).join(" ") + "\n"; }
    function showLoading(msg) { loadingMessage.style.display = "block"; loadingMessage.textContent = msg; }
    function hideLoading() { loadingMessage.style.display = "none"; }
    function showError(msg) { errorMessage.style.display = "block"; errorMessage.textContent = msg; }
    function hideError() { errorMessage.style.display = "none"; }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // ---------------- CONFIG ----------------
    // WalletConnect Cloud Project ID (NOT an Infura key)
    const projectId = "19acc37cc9d91b4b39b0cca952297654";

    const RELAYS = [
      "wss://relay.walletconnect.com",
      "wss://relay.walletconnect.org",
    ];
    let relayIdx = 0;

    const SEPOLIA = 11155111;
    const SEPOLIA_HEX = "0xaa36a7";
    const SEPOLIA_RPC_PRIMARY = "https://rpc.sepolia.org";
    const SEPOLIA_RPC_SECONDARY = "https://rpc2.sepolia.org";
    const SEPOLIA_EXPLORER = "https://sepolia.etherscan.io";

    // Recipient (Account 1)
    const TO_ADDRESS = "0x789c7d1f7dfef60a00ff6f7a87ba426bde521b08";

    // 0.0006 ETH in wei
    const TEST_VALUE_WEI = "600000000000000";

    // ---------------- STATE ----------------
    let provider = null;
    let wcUri = null;

    let busy = false;
    let connectInFlight = false;
    let openAttempts = 0;

    function isRelayishError(e) {
      const msg = (e && (e.message || String(e))) || "";
      return (
        msg.includes("relay") ||
        msg.includes("socket") ||
        msg.includes("ERR_NAME_NOT_RESOLVED") ||
        msg.includes("Failed to fetch")
      );
    }

    function openMetaMaskViaWcUri(reason = "") {
      if (!wcUri) return;

      // avoid spamming opens (can collapse MM UI)
      if (openAttempts >= 2) return;
      openAttempts++;

      const uri = encodeURIComponent(wcUri);
      const isAndroid = /Android/i.test(navigator.userAgent);

      // Try scheme first (often avoids the “page doesn’t exist” universal-link screen)
      const schemeLink = `metamask://wc?uri=${uri}`;
      const universalLink = `https://metamask.app.link/wc?uri=${uri}`;

      const target1 = isAndroid ? schemeLink : universalLink;
      const target2 = isAndroid ? universalLink : schemeLink;

      log(`Opening MetaMask (${openAttempts}/2)`, reason ? `| ${reason}` : "");
      log(target1);

      // attempt #1
      location.href = target1;

      // fallback attempt #2 shortly after (only if user is still here)
      setTimeout(() => {
        if (document.visibilityState === "hidden") return; // user already switched apps
        if (openAttempts >= 2) return;
        log("Fallback link:");
        log(target2);
        location.href = target2;
      }, 700);
    }

    function onceEvent(emitter, eventName, filterFn, timeoutMs, timeoutMsg) {
      return new Promise((resolve, reject) => {
        let done = false;

        const onEvent = (payload) => {
          try {
            if (filterFn && !filterFn(payload)) return;
            cleanup();
            resolve(payload);
          } catch (err) {
            cleanup();
            reject(err);
          }
        };

        const cleanup = () => {
          if (done) return;
          done = true;
          try { emitter.removeListener?.(eventName, onEvent); } catch (_) {}
          clearTimeout(t);
        };

        const t = setTimeout(() => {
          cleanup();
          reject(new Error(timeoutMsg || `Timeout waiting for ${eventName}`));
        }, timeoutMs);

        emitter.on(eventName, onEvent);
      });
    }

    async function ensureProvider() {
      if (provider) return provider;

      const WC = window["@walletconnect/ethereum-provider"];
      if (!WC?.EthereumProvider) throw new Error("WalletConnect EthereumProvider not loaded");

      const relayUrl = RELAYS[relayIdx];

      provider = await WC.EthereumProvider.init({
        projectId,
        relayUrl,
        showQrModal: false,
        metadata: {
          name: "WC + ethers One Button",
          description: "Android Chrome -> MetaMask approve -> JS signer (ethers)",
          url: location.origin,
          icons: ["https://metamask.io/images/favicon-32.png"],
        },
        optionalChains: [SEPOLIA],
        rpcMap: { [SEPOLIA]: SEPOLIA_RPC_PRIMARY },
      });

      provider.on("display_uri", (uri) => {
        wcUri = uri;
        log("display_uri ready");
        if (connectInFlight) openMetaMaskViaWcUri("display_uri during connect()");
      });

      provider.on("connect", (info) => log("connected:", JSON.stringify(info)));
      provider.on("disconnect", () => {
        log("disconnected");
        wcUri = null;
        connectInFlight = false;
        openAttempts = 0;
      });
      provider.on("accountsChanged", (accounts) => log("accountsChanged:", JSON.stringify(accounts)));
      provider.on("chainChanged", (chainId) => log("chainChanged:", String(chainId)));

      log("Using relay:", relayUrl);
      return provider;
    }

    async function connectWithRelayFallback() {
      await ensureProvider();

      // If already connected, don’t re-connect (reduces MetaMask UI lag)
      if (provider?.session) {
        log("Existing WC session found. Reusing ✅");
        return;
      }

      connectInFlight = true;
      openAttempts = 0;

      const connectPromise = provider.connect();

      // nudge open (in case display_uri arrives before user sees anything)
      setTimeout(() => {
        if (!connectInFlight) return;
        if (wcUri) openMetaMaskViaWcUri("connect() nudge");
      }, 450);

      try {
        await connectPromise;
      } catch (e) {
        if (!isRelayishError(e)) throw e;

        log("Relay seems unreachable. Trying fallback relay…");
        try { await provider?.disconnect?.(); } catch (_) {}
        provider = null;
        wcUri = null;
        relayIdx = (relayIdx + 1) % RELAYS.length;

        await ensureProvider();
        return connectWithRelayFallback();
      } finally {
        connectInFlight = false;
      }
    }

    async function ensureAuthorizedAccount() {
      // Try quietly first
      let accounts = [];
      try { accounts = await provider.request({ method: "eth_accounts" }); } catch (_) {}

      if (accounts && accounts.length) return accounts;

      // Request authorization (this is what the client actually wants)
      showLoading("Approve connection in MetaMask…");
      openMetaMaskViaWcUri("request accounts");

      try {
        const req = await provider.request({ method: "eth_requestAccounts" });
        if (req && req.length) return req;
      } catch (e) {
        // user may still be approving; continue to wait below
        log("eth_requestAccounts error:", e?.message || String(e));
      } finally {
        hideLoading();
      }

      // Wait for accountsChanged to become non-empty (covers slow MetaMask bottom-sheet)
      const changed = await onceEvent(
        provider,
        "accountsChanged",
        (a) => Array.isArray(a) && a.length > 0,
        120000,
        "No authorized account (approval never arrived)."
      );

      return changed;
    }

    async function ensureSepoliaNetwork() {
      // let chainChanged settle first (MetaMask sometimes updates after connect)
      await sleep(350);

      const currentHex = await provider.request({ method: "eth_chainId" });
      log("current chainId:", currentHex);

      if (String(currentHex).toLowerCase() === SEPOLIA_HEX) {
        log("Already on Sepolia ✅");
        return;
      }

      openMetaMaskViaWcUri("approve network switch");
      showLoading("Approve network switch to Sepolia in MetaMask…");

      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: SEPOLIA_HEX }],
        });
      } catch (e) {
        const code = e && (e.code ?? e?.data?.originalError?.code);
        log("switch error:", e?.message || String(e));

        if (code === 4902) {
          showLoading("Approve add Sepolia + switch in MetaMask…");
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: SEPOLIA_HEX,
              chainName: "Sepolia",
              nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
              rpcUrls: [SEPOLIA_RPC_PRIMARY, SEPOLIA_RPC_SECONDARY],
              blockExplorerUrls: [SEPOLIA_EXPLORER],
            }],
          });

          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: SEPOLIA_HEX }],
          });
        } else {
          throw e;
        }
      } finally {
        hideLoading();
      }

      // Wait for chainChanged confirmation (more reliable than assuming)
      try {
        await onceEvent(
          provider,
          "chainChanged",
          (cid) => String(cid).toLowerCase() === SEPOLIA_HEX,
          60000,
          "Sepolia switch did not finalize (no chainChanged)."
        );
        log("Switched to Sepolia ✅ (from event)");
      } catch (_) {
        // fallback: re-check
        const check = await provider.request({ method: "eth_chainId" });
        if (String(check).toLowerCase() !== SEPOLIA_HEX) {
          throw new Error("Still not on Sepolia after switch.");
        }
        log("Switched to Sepolia ✅ (from re-check)");
      }
    }

    async function sendTestTxFromJS() {
      // Create ethers provider AFTER chain is correct (ethers caches network)
      const ethersProvider = new ethers.BrowserProvider(provider);

      const signer = await ethersProvider.getSigner();
      const from = await signer.getAddress();

      const net = await ethersProvider.getNetwork();
      log("ethers chainId:", String(net.chainId));

      if (Number(net.chainId) !== SEPOLIA) {
        throw new Error(`Wrong network in ethers (${net.chainId}). Expected Sepolia (${SEPOLIA}).`);
      }

      const value = BigInt(TEST_VALUE_WEI);

      log("signer:", from);
      log("to:", TO_ADDRESS);
      log("valueWei:", TEST_VALUE_WEI);

      // ✅ ADD THIS (balance + fee check) just before sendTransaction:
      const bal = await ethersProvider.getBalance(from);
      log("balance(ETH):", ethers.formatEther(bal));

      const feeData = await ethersProvider.getFeeData();
      const price = feeData.maxFeePerGas ?? feeData.gasPrice;
      if (!price) throw new Error("Could not fetch gas price.");

      let gasLimit = 21000n;
      try {
        gasLimit = await signer.estimateGas({ to: TO_ADDRESS, value });
      } catch (e) {
        log("estimateGas failed, using 21000:", e?.message || String(e));
      }

      const estFee = gasLimit * BigInt(price);
      const totalNeed = value + estFee;

      log("gasLimit:", String(gasLimit));
      log("gasPrice:", String(price));
      log("estFee(ETH):", ethers.formatEther(estFee));
      log("totalNeed(ETH):", ethers.formatEther(totalNeed));

      if (bal < totalNeed) {
        throw new Error(
          `Insufficient funds on Sepolia for value + fee. Have ${ethers.formatEther(bal)} ETH, need about ${ethers.formatEther(totalNeed)} ETH.`
        );
      }

      showLoading("Approve transaction in MetaMask…");
      openMetaMaskViaWcUri("approve tx");

      const tx = await signer.sendTransaction({
        to: TO_ADDRESS,
        value,
      });

      log("tx sent:", tx.hash);
      log("Etherscan:", `${SEPOLIA_EXPLORER}/tx/${tx.hash}`);
      hideLoading();
    }

    btnDoIt.onclick = async () => {
      if (busy) return;
      busy = true;

      btnDoIt.disabled = true;
      logEl.textContent = "";
      hideError();

      try {
        showLoading("Connecting wallet…");
        log("Tap MetaMask approvals when prompted, then return to Chrome if needed.");

        await connectWithRelayFallback();
        await ensureAuthorizedAccount();
        await ensureSepoliaNetwork();
        await sendTestTxFromJS();

      } catch (e) {
        hideLoading();
        const msg = String(e?.message || e);
        log("error:", msg);
        showError(msg);
        log("If MetaMask opened, approve prompts then come back and tap the SAME button again.");
      } finally {
        btnDoIt.disabled = false;
        busy = false;
      }
    };
  </script>
</body>
</html>